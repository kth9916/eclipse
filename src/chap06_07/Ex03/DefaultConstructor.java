package chap06_07.Ex03;

// 기본 생성자 : class A는 기본 생성자가 생략되어 있다
// 일반적으로 클래스 블락에 1. 필드, 2. 생성자, 3. 메소드 형식으로 작성한다.
// 생성자의 역활 : 1. 객체 생성 2. 필드의 값을 초기화 

class A{
	int m; 				//필드(클래스 블락에 선언된 변수) : 	데이터타입 변수명
							// 힙 영역에 저장, 객체화 시켜야 사용가능, 예외) static
							// 힙 영역의 RAM에는 반드시 초기값이 들어가야 한다
	
//	A (){} 			// <== 기본 생성자 : 클래스 이름과 동일하면서 리턴타입이 없는 메소드를 생성자라 호칭 한다.
					// 기본 생성자는 생략 가능 하다
					// 기본 생성자는 매개변수도 없고 실행부도 가지지 않는 생성자
	
	void work() {		// 메소드 : 	리턴타입 메소드명 (인풋 매개변수) {실행부}
							// 메소드 호출 : work() 
		System.out.println(m); //0			//m : 메모리의 값을 가지고 온다
		
	}
}

class B{
	int m; 			// m은 Heap 영역에 저장이 되고, 기본 값으로 0을 출력
	
	B(){} 			// 기본 생성자는 생략 가능하다. 객체의 필드의 초기값을 기본값으로 출력
	
	void work() {
		System.out.println(m); 		// 0 		메모리의 초기값으로 0을 출력
	}
	
}

// 객체 생성시 생성자를 통해서 필드의 초기값을 할당하고 객체 생성, 

class C{
	int m;
	
	// C (){}				// 기본 생성자는 생략됨, 다른 생성자가 존재하는 경우 외부에서 기본 생성자 호출시
							// 기본 생성자는 생략되면 안된다
	
	C (int c){		// 생성자의 인풋 값을 받아서 메모리의 기본값으로 m변수 값을 로드 시킨다
		m = c;
	}
	
	void work() {
		System.out.println(m); 		// m은 객체 생성시 생성자에 정수 값을 넣어서 필드 m을 초기화 시켜줌
	}
	
}

class D{
	int m , n , l ;
	
	D(){} 						// 기본 생성자
	D(int m, int n){ 			//매개변수 2개
		this.m = m; 			// this : 자기 자신의 객체, 지역변수가 아니라 필드의 변수를 알려줌
		this.n = n;
		
	}
	D (int a, int b, int c){ 	// 매개 변수가 3개인 생성자
		m = a;
		n = b;
		l = c;
	}
	
	void work() {				//work()를 호출시 각각의 메모리의 값을 출력
		System.out.println("m : " + m + ", n : " + n + ", l : " + l);
	}
	
}


public class DefaultConstructor {

	public static void main(String[] args) {
		// 클래스 내에 포함될 수 있는 것 : 1. 필드, 2. 메소드, 3. 생성자, 4. 이너 클래스(innerClass)
		// 생성자의 2가지 특징 : 1. 클래스 이름과 동일한 이름을 가진 메소드를 생성자라 한다.
				// 			2. 생성자는 반환 타입이 없다. (메소드는 반환타입이 있다.)
		// 생성자를 사용하는 이유 : 객체를 생성할 때 필드의 값을 초기화 하면서 객체를 생성하고자 할 때 사용.
		 		// 클래스 내에서 필드의 초기 값은 일반적으로 할당하지 않는다.
				// 클래스의 객체를 생성할 때 초기 값을 할당하면서 객체를 생성할 때 
		
		// 객체를 생성할 때, 반드시 생성자를 호출, A a = new A();  <== 객체 생성 구문
									// /틀/객체/heap/생성자
		
		// 기본 생성자 ( Default Constructor )
			// 인풋 매개변수가 없는 생성자, 실행부의 값도 비어있는 상태의 생성자.
			// 기본 생성자는 생략 가능
			// 생략되어 있을 경우, 컴파일러가 자동으로 생성해서 컴파일
			// 클래스 내의 기본 생성자 이외의 다른 생성자가 조내하는 경우, 기본 생성자 호출시 생략되면 안된다.
			
		A a = new A(); 				// A(); : 기본 생성자 호출
									// 객체 생성시 반드시 생성자를 호출 해야 한다.
		a.work();
		
		B b = new B(); // <<<기본 생성자 호출>>>
		
		b.work(); 	// 0 < == 객체의 초기값 출력 :
		
		C c = new C(3); 	// << 생성자 호출시 기본값을 인풋해서 메모리 필드에 초기값 구성
		c.work();			// 객체 생성시 기본기능 : 객체 생성과 + 필드의 값을 초기화
		
		C cc = new C(5);
		cc.work();
		
		C ccc = new C(10);
		ccc.work();
		
//		C cccc = new C(); 	// 오류 발생 : 기본생성자가 생략, 다른 생성자가 존재 << 기본생성자 호출>>
		
		// class C는 기본 생성자가 생략 되어 있다. // C(){}
		// class C는 인풋 매개변수가 하나인 생성자가 존재 
		
		D d = new D(); 		// 기본 생성자 호출, 객체의 필드의 초기값(0,0,0)
		d.work(); 			// 
		
		D dd = new D(3,4,5); 	// 매개 변수가 3개인 생성자 호출
		dd.work();
		
		D ddd = new D(1,2); 	// 매개 변수가 정수 2개인 생성자를 호출
		ddd.work();
		
		
		// 객체 내의 필드의 값을 초기화 할 때 오버로딩(OverLoading)에 의해서 해당 생성자가 호출
			// 오버로딩 : 메소드명 (생성자명, 데이터타입, 매개변수 갯수) < == 시그니처
				// 오류가 발생되는 경우 : 동일한 데이터 타입, 같은 갯수, 동일한 생성자
	}	

}
